#!/usr/bin/env python
"""
This script obtains the dependencies for the terraform config wrapper files and generates a visualization

Usage:
    visualize.py [options] <path>

Arguments:
    path    The path of the config directory to check

Options:
    -h, --help          Show this message and exit.[default: False]
    -d, --dependencies  Show dependency info for a single wrapper file.[default: False]
    -s, --show          Show a visual graph for this command.[default: False]
"""

import os
import networkx
import matplotlib.pylab as p

from docopt import docopt

from terrawrap.utils.version import version_check
from terrawrap.version import __version__

from terrawrap.utils.config import directory_dependency_grapher, single_config_dependency_grapher
from terrawrap.utils.graph import find_source_nodes, generate_dependencies, visualize, has_cycle


SCRIPT_DIR = os.path.abspath(os.path.dirname(__file__))
CURRENT_DIRECTORY = os.getcwd()


def main():
    version_check(current_version=__version__)
    arguments = docopt(__doc__, version="Terrawrap %s" % __version__)

    only_dependencies = arguments['--dependencies']
    show = arguments['--show']

    # Get the directory with Terraform config passed to this script as an argument
    config_dir = arguments['<path>']
    if not os.path.isabs(config_dir):
        config_dir = os.path.abspath(os.path.join(CURRENT_DIRECTORY, config_dir))

    if not os.path.isdir:
        config_dir = os.path.dirname(config_dir)

    post_graph = []
    print("Visualizing Dependencies for %s:" % config_dir)
    if only_dependencies:
        graph = networkx.DiGraph()
        visited = []
        single_config_dependency_grapher(config_dir, graph, visited)
    else:
        graph, post_graph = directory_dependency_grapher(config_dir)

    if has_cycle(graph):
        print("Terrawrap has detected a cycle. There is no source dependency for apply")
        exit(1)

    sources = find_source_nodes(graph)
    dependencies = generate_dependencies(sources, graph)
    visualize(dependencies)
    if post_graph:
        print("The following files have not been configured and will be run in parallel after the graph has run.")
        print(post_graph)

    if show:
        networkx.draw(graph, with_labels=True)
        p.show()
    exit(0)


if __name__ == '__main__':
    main()
